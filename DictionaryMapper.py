from copy import copy
import flatdict



class Mapper:
    def __init__(self, input_dict, mappings, paths):
        self.input_dict = input_dict
        self.mappings = mappings
        self.paths = paths
        self.result = []
        self.path = []
        self.value = []
    #  Finds every possible path ways in a dictionary for a given key
    def find_path(self, dict_obj, key, i=None):
        for k, v in dict_obj.items():
            self.path.append(k)

            if isinstance(v, dict):
                self.find_path(v, key, i)

            if isinstance(v, list):
                for i, item in enumerate(v):
                    self.path.append(i)

                    if isinstance(item, dict):
                        self.find_path(item, key, i)

                    self.path.pop()

            if k == key:
                self.result.append(copy(self.path))

            if self.path != []:
                self.path.pop()

        return self.result
    # Uses find_key to generate a list of possible paths
    def generate_paths_from_key(self, paths):
        last_keys = []
        split_keys = []

        if len(paths) > 1:
            for x in range(len(paths)):
                list = paths[x]
                key = list[0]
                key = key.split('.')
                split_keys.append(key)
                last_key = key[-1]
                last_keys.append(last_key)

        for key in last_keys:
            self.find_path(self.input_dict, key)
    # Converts list to binary for comparison
    def convert_to_binary(self, paths):
        binary_list = []

        for sublist in paths:
            binary_sublist = []

            for elem in sublist:
                if elem == "*" or isinstance(elem, int):
                    binary_sublist.append(0)
                else:
                    binary_sublist.append(1)

            binary_list.append(binary_sublist)

        return binary_list
    # from the paths given and the possible paths generated by keys from paths we find the paths of the keys. Here convert_to_binary is used
    def generate_possible_paths(self, paths):
        path = []
        possible_paths = []

        for item in paths:
            l = item[0].split('.')
            path.append(l)

        binary_path = self.convert_to_binary(path)
        binary_possible_paths = self.convert_to_binary(self.result)

        for index, p in enumerate(binary_possible_paths):
            if p in binary_path:
                possible_paths.append(self.result[index])

        return possible_paths
    # Here we join blown strings
    def join(self, string):
        return '.'.join(map(str, string))


    def find_values_of_paths(self, input_dict, list_of_list):
        d = flatdict.FlatDict(input_dict, delimiter='.')
        value = None
        result = []

        for key_list in list_of_list:
            for k in key_list:
                if isinstance(k, str):
                    try:
                        value = d[k]
                    except:
                        value = value[k]

                elif isinstance(k, int):
                    value = flatdict.FlatDict(value[k], delimiter='.')

            result.append(value)

        return result
    
    def deepupdate(self,original, update):
        for key, value in update.items():
            if isinstance(value, dict):
                original_value = original.get(key, {})
                if not isinstance(original_value, dict):
                    original_value = {}
                original[key] = self.deepupdate(original_value, value)
            elif isinstance(value, list):
                if key in original and isinstance(original[key], list):
                    original[key].extend(value)
                else:
                    original[key] = value
            else:
                original[key] = value
        return original
    
    def create_nested_dict(self,keys, value):
        if not keys:
            return value
        elif keys[0] == "*":
            return [self.create_nested_dict(keys[1:], value)]
        else:
            return {keys[0]: self.create_nested_dict(keys[1:], value)}
    # Creates new dictionaries from mapping and given values
    def new_dict(self,mappings,values):
        paths = []
        output_dict = []
        for k,v in mappings.items():
            
            blow = v.split('.')
            paths.append(blow) 

        for i,path in enumerate(paths):
            try:
                value = values[i] 
                nested_dict = self.create_nested_dict(path, value)
                output_dict.append(nested_dict)
            except:
                print("No possible paths")
        return output_dict
    # merges new dictinaries
    def merge_dicts(self,dicts_list):
        result = {}
        for d in dicts_list:
            result = self.deepupdate(result, d)
        return result  

    def map(self):
        self.generate_paths_from_key(self.paths)
        possible_paths = self.generate_possible_paths(self.paths)
        values_to_possible_paths = self.find_values_of_paths(self.input_dict,possible_paths)
        output_dicts = self.new_dict(self.mappings, values_to_possible_paths)
        output_dict = self.merge_dicts(output_dicts)
        
        return output_dict

    
input_dict = {'key1': {'key2': {'key3': {'key4': [{'key5': 'value0',
                                                  'key6': [{'key7': {'key9': ['a', 'b'],
                                                                     'key10': ['foo'],
                                                                     'key11': [{'key5': 'value8'},
                                                                               {'key5': 'value1'},
                                                                               {'key5': 'value2'},
                                                                               {'key5': 'value3'},
                                                                               {'key5': 'value4'}]},
                                                            'key5': 'value5',
                                                            'key8': {'key12': [None],
                                                                     'key13': 'value5'}},
                                                   {'key7': {'key9': ['a'],
                                                             'key10': ['foo']},
                                                    'key5': 'value6',
                                                    'key8': {'key13': 'value6',
                                                             'reject': {}}},
                                                   {'key5': 'value7',
                                                    'key8': {'key12': [None]}}]}]}}}}

mappings = {
    'key1.key2.key3.key4.*.key5': 'new_key1.new_key2.*.new_key3',
    'key1.key2.key3.key4.*.key6.*.key7.key11': 'new_key1.new_key2.*.new_key4.*.new_key5'}

paths = [["key1.key2.key3.key4.*.key5"],
         ["key1.key2.key3.key4.*.key6.*.key7.key11"], ]

m = Mapper(input_dict,mappings,paths)
print(m.map())